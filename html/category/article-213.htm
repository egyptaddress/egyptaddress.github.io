<!doctype html>
<html lang="zh-CN">

<head>
        <link rel="canonical" href="https://egyptaddress.github.io/html/category/article-213.htm" />
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
    <title>Redis 如何保证数据库和缓存双写一致性？ - EgyptAddress</title>
    <link rel="icon" href="/assets/addons/xcblog/img/egyptaddress/favicon.ico" type="image/x-icon"/>
        <link href="https://fonts.googleapis.com/css2?family=Jost:wght@300;400;600&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="/assets/addons/xcblog/css/egyptaddress/style-starter.css">
        </head>

<body>
        <!-- header -->
    <header id="site-header" class="fixed-top">
        <div class="container">
            <nav class="navbar navbar-expand-lg stroke">
                <a class="navbar-brand" href="/">
                                        <span class="fa fa-laptop"></span> EgyptAddress
                                    </a>
                <button class="navbar-toggler  collapsed bg-gradient" type="button" data-toggle="collapse" data-target="#navbarTogglerDemo02" aria-controls="navbarTogglerDemo02" aria-expanded="false" aria-label="Toggle navigation">
                    <span class="navbar-toggler-icon fa icon-expand fa-bars"></span>
                    <span class="navbar-toggler-icon fa icon-close fa-times"></span>
                    </span>
                </button>
                <div class="collapse navbar-collapse" id="navbarTogglerDemo02">
                    <ul class="navbar-nav ml-auto">
                                                <li class="nav-item">
                            <a class="nav-link" href="/xcblog/">首页</a>
                        </li>
                                                <li class="nav-item">
                            <a class="nav-link" href="/html/category/">文章分类</a>
                        </li>
                                                <li class="nav-item">
                            <a class="nav-link" href="#">关于</a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link" href="#">联系</a>
                        </li>
                    </ul>
                </div>
                <!-- toggle switch for light and dark theme -->
                <div class="mobile-position">
                    <nav class="navigation">
                        <div class="theme-switch-wrapper">
                            <label class="theme-switch" for="checkbox">
                                <input type="checkbox" id="checkbox">
                                <div class="mode-container">
                                    <i class="gg-sun"></i>
                                    <i class="gg-moon"></i>
                                </div>
                            </label>
                        </div>
                    </nav>
                </div>
                <!-- //toggle switch for light and dark theme -->
            </nav>
        </div>
    </header>
    <!-- //header -->
    
    <!-- about breadcrumb -->
    <section class="w3l-about-breadcrumb text-center">
        <div class="breadcrumb-bg breadcrumb-bg-about py-sm-5 py-4">
            <div class="container py-2">
                <h1 class="title" style="word-break: break-all;">Redis 如何保证数据库和缓存双写一致性？</h1>
                <ul class="breadcrumbs-custom-path mt-2">
                    <li><a href="/">首页</a></li>
                    <li><span class="fa fa-arrow-right mx-2" aria-hidden="true"></span></li>
                    <li><a href="/html/category/">文章分类</a></li>
                    <li class="active"><span class="fa fa-arrow-right mx-2" aria-hidden="true"></span> 正文</li>
                </ul>
            </div>
        </div>
    </section>
    <!-- //about breadcrumb -->
    <div class="container py-lg-5 py-3">
        <div class="row">
            <div class="col-md-8">
                <div class="post-content-content">
                      				  				  				<div id="content_views" class="htmledit_views"> <div> <p style="margin-left:0;text-align:left;"><strong><span style="color:#333333;">前言</span></strong></p> </div> <p style="margin-left:0;text-align:left;"><span style="color:#333333;">数据库和缓存（比如：</span><span style="color:#333333;">redis</span><span style="color:#333333;">）双写数据一致性问题，是一个跟开发语言无关的公共问题。尤其在高并发的场景下，这个问题变得更加严重。</span></p> <p style="margin-left:0;text-align:left;"><span style="color:#333333;">我很负责的告诉大家，该问题无论在面试，还是工作中遇到的概率非常大，所以非常有必要跟大家一起探讨一下。</span></p> <p style="margin-left:0;text-align:left;"><span style="color:#333333;">今天这篇文章我会从浅入深，跟大家一起聊聊，数据库和缓存双写数据一致性问题常见的解决方案，这些方案中可能存在的坑，以及最优方案是什么。</span></p> <div> <p style="margin-left:0;text-align:left;"><strong><span style="color:#333333;">1.</span></strong><strong><span style="color:#333333;">常见方案</span></strong></p> </div> <p style="margin-left:0;text-align:left;"><span style="color:#333333;">通常情况下，我们使用缓存的主要目的是为了提升查询的性能。大多数情况下，我们是这样使用缓存的：</span><img fetchpriority="high" decoding="async" alt="" height="688" src="http://img.555519.xyz/uploads3/20220821/b13f3922de2d5126ce0f2d01183be98f.jpg"></p> <ol> <li style="text-align:left;"><span style="color:#333333;">用户请求过来之后，先查缓存有没有数据，如果有则直接返回。</span></li> <li style="text-align:left;"><span style="color:#333333;">如果缓存没数据，再继续查数据库。</span></li> <li style="text-align:left;"><span style="color:#333333;">如果数据库有数据，则将查询出来的数据，放入缓存中，然后返回该数据。</span></li> <li style="text-align:left;"><span style="color:#333333;">如果数据库也没数据，则直接返回空。</span></li> </ol> <p style="margin-left:0;text-align:left;"><span style="color:#333333;">这是缓存非常常见的用法。一眼看上去，好像没有啥问题。</span></p> <p style="margin-left:0;text-align:left;"><span style="color:#333333;">但你忽略了一个非常重要的细节：<strong>如果数据库中的某条数据，放入缓存之后，又立马被更新了，那么该如何更新缓存呢？</strong></span></p> <p style="margin-left:0;text-align:left;"><span style="color:#333333;">不更新缓存行不行？</span></p> <p style="margin-left:0;text-align:left;"><span style="color:#333333;">答：当然不行，如果不更新缓存，在很长的一段时间内（决定于缓存的过期时间），用户请求从缓存中获取到的都可能是旧值，而非数据库的最新值。这不是有数据不一致的问题？</span></p> <p style="margin-left:0;text-align:left;"><span style="color:#333333;">那么，我们该如何更新缓存呢？</span></p> <p style="margin-left:0;text-align:left;"><span style="color:#333333;">目前有以下</span><span style="color:#333333;">4</span><span style="color:#333333;">种方案：</span></p> <ol> <li style="text-align:left;"><span style="color:#333333;">先写缓存，再写数据库</span></li> <li style="text-align:left;"><span style="color:#333333;">先写数据库，再写缓存</span></li> <li style="text-align:left;"><span style="color:#333333;">先删缓存，再写数据库</span></li> <li style="text-align:left;"><span style="color:#333333;">先写数据库，再删缓存</span></li> </ol> <p style="margin-left:0;text-align:left;"><span style="color:#333333;">接下来，我们详细说说这</span><span style="color:#333333;">4</span><span style="color:#333333;">种方案。</span></p> <div> <p style="margin-left:0;text-align:left;"><strong><span style="color:#333333;">2.</span></strong><strong><span style="color:#333333;">先写缓存，再写数据库</span></strong></p> </div> <p style="margin-left:0;text-align:left;"><span style="color:#333333;">对于更新缓存的方案，很多人第一个想到的可能是在写操作中直接更新缓存（写缓存），更直接明了。</span></p> <p style="margin-left:0;text-align:left;"><span style="color:#333333;">那么，问题来了：在写操作中，到底是先写缓存，还是先写数据库呢？</span></p> <p style="margin-left:0;text-align:left;"><span style="color:#333333;">我们在这里先聊聊先写缓存，再写数据库的情况，因为它的问题最严重。</span><img decoding="async" alt="" height="416" src="http://img.555519.xyz/uploads3/20220821/09f58fec7e82f29c3421ec9c418951e8.jpg"></p> <p style="margin-left:0;text-align:left;"><span style="color:#333333;">某一个用户的每一次写操作，如果刚写完缓存，突然网络出现了异常，导致写数据库失败了。</span></p> <p style="margin-left:0;text-align:left;"><img decoding="async" alt="" height="416" src="http://img.555519.xyz/uploads3/20220821/8dbff0716fa96166b7eeee89c615fe51.jpg"></p> <p style="margin-left:0;text-align:left;"><span style="color:#333333;">其结果是缓存更新成了最新数据，但数据库没有，这样缓存中的数据不就变成脏数据了？如果此时该用户的查询请求，正好读取到该数据，就会出现问题，因为该数据在数据库中根本不存在，这个问题非常严重。</span></p> <p style="margin-left:0;text-align:left;"><span style="color:#333333;">我们都知道，缓存的主要目的是把数据库的数据临时保存在内存，便于后续的查询，提升查询速度。</span></p> <p style="margin-left:0;text-align:left;"><span style="color:#333333;">但如果某条数据，在数据库中都不存在，你缓存这种</span><span style="color:#333333;">“</span><span style="background-color:#f3f4f4;"><span style="color:#333333;">假数据</span></span><span style="color:#333333;">”</span><span style="color:#333333;">又有啥意义呢？</span></p> <p style="margin-left:0;text-align:left;"><span style="color:#333333;">因此，先写缓存，再写数据库的方案是不可取的，在实际工作中用得不多。</span></p> <div> <p style="margin-left:0;text-align:left;"><strong><span style="color:#333333;">3.</span></strong><strong><span style="color:#333333;">先写数据库，再写缓存</span></strong></p> </div> <p style="margin-left:0;text-align:left;"><span style="color:#333333;">既然上面的方案行不通，接下来，聊聊先写数据库，再写缓存的方案，该方案在低并发编程中有人在用（我猜的）。</span></p> <p style="margin-left:0;text-align:left;"><img loading="lazy" decoding="async" alt="" height="394" src="http://img.555519.xyz/uploads3/20220821/3fda48f4718eb8c35ac3f54892b979aa.jpg"></p> <p style="margin-left:0;text-align:left;"><span style="color:#333333;">用户的写操作，先写数据库，再写缓存，可以避免之前</span><span style="color:#333333;">“</span><span style="color:#333333;">假数据</span><span style="color:#333333;">”</span><span style="color:#333333;">的问题。但它却带来了新的问题。</span></p> <p style="margin-left:0;text-align:left;"><span style="color:#333333;">什么问题呢？</span></p> <p style="margin-left:0;text-align:left;"><strong><span style="color:#333333;">3.1</span></strong><strong><span style="color:#333333;">写缓存失败了</span></strong></p> <p style="margin-left:0;text-align:left;"><span style="color:#333333;">如果把写数据库和写缓存操作，放在同一个事务当中，当写缓存失败了，我们可以把写入数据库的数据进行回滚。</span></p> <p style="margin-left:0;text-align:left;"><img loading="lazy" decoding="async" alt="" height="406" src="http://img.555519.xyz/uploads3/20220821/04cb2395a578240f067b6b839dc6bc7b.jpg"></p> <p style="margin-left:0;text-align:left;"><span style="color:#333333;">如果是并发量比较小，对接口性能要求不太高的系统，可以这么玩。</span></p> <p style="margin-left:0;text-align:left;"><span style="color:#333333;">但如果在高并发的业务场景中，写数据库和写缓存，都属于远程操作。为了防止出现大事务，造成的死锁问题，通常建议写数据库和写缓存不要放在同一个事务中。</span></p> <p style="margin-left:0;text-align:left;"><span style="color:#333333;">也就是说在该方案中，如果写数据库成功了，但写缓存失败了，数据库中已写入的数据不会回滚。</span></p> <p style="margin-left:0;text-align:left;"><span style="color:#333333;">这就会出现：数据库是</span><span style="background-color:#f3f4f4;"><span style="color:#333333;">新数据</span></span><span style="color:#333333;">，而缓存是</span><span style="background-color:#f3f4f4;"><span style="color:#333333;">旧数据</span></span><span style="color:#333333;">，两边</span><span style="background-color:#f3f4f4;"><span style="color:#333333;">数据不一致</span></span><span style="color:#333333;">的情况。</span></p> <p style="margin-left:0;text-align:left;"><strong><span style="color:#333333;">3.1</span></strong><strong><span style="color:#333333;">高并发下的问题</span></strong></p> <p style="margin-left:0;text-align:left;"><span style="color:#333333;">假设在高并发的场景中，针对同一个用户的同一条数据，有两个写数据请求：</span><span style="color:#333333;">a</span><span style="color:#333333;">和</span><span style="color:#333333;">b</span><span style="color:#333333;">，它们同时请求到业务系统。</span></p> <p style="margin-left:0;text-align:left;"><span style="color:#333333;">其中请求</span><span style="color:#333333;">a</span><span style="color:#333333;">获取的是旧数据，而请求</span><span style="color:#333333;">b获取的是新数据，如下图所示：</span><img loading="lazy" decoding="async" alt="" height="508" src="http://img.555519.xyz/uploads3/20220821/5cbfd39c881b652d27d3a137eeba0af3.jpg"></p> <ol> <li style="text-align:left;"><span style="color:#333333;">请求a先过来，刚写完了数据库。但由于网络原因，卡顿了一下，还没来得及写缓存。</span></li> <li style="text-align:left;"><span style="color:#333333;">这时候请求b过来了，先写了数据库。</span></li> <li style="text-align:left;"><span style="color:#333333;">接下来，请求b顺利写了缓存。</span></li> <li style="text-align:left;"><span style="color:#333333;">此时，请求a卡顿结束，也写了缓存。</span></li> </ol> <p style="margin-left:0;text-align:left;"><span style="color:#333333;">很显然，在这个过程当中，请求</span><span style="color:#333333;">b</span><span style="color:#333333;">在缓存中的</span><span style="background-color:#f3f4f4;"><span style="color:#333333;">新数据</span></span><span style="color:#333333;">，被请求</span><span style="color:#333333;">a</span><span style="color:#333333;">的</span><span style="background-color:#f3f4f4;"><span style="color:#333333;">旧数据</span></span><span style="color:#333333;">覆盖了。</span></p> <p style="margin-left:0;text-align:left;"><span style="color:#333333;">也就是说：在高并发场景中，如果多个线程同时执行先写数据库，再写缓存的操作，可能会出现数据库是新值，而缓存中是旧值，两边数据不一致的情况。</span></p> <p style="margin-left:0;text-align:left;"><strong><span style="color:#333333;">3.2</span></strong><strong><span style="color:#333333;">浪费系统资源</span></strong></p> <p style="margin-left:0;text-align:left;"><span style="color:#333333;">该方案还有一个比较大的问题就是：每个写操作，写完数据库，会马上写缓存，比较</span><span style="background-color:#f3f4f4;"><span style="color:#333333;">浪费系统资源</span></span><span style="color:#333333;">。</span></p> <p style="margin-left:0;text-align:left;"><span style="color:#333333;">为什么这么说呢？</span></p> <p style="margin-left:0;text-align:left;"><span style="color:#333333;">你可以试想一下，如果写的缓存，并不是简单的数据内容，而是要经过非常复杂的计算得出的最终结果。这样每写一次缓存，都需要经过一次非常复杂的计算，不是非常浪费系统资源吗？</span></p> <p style="margin-left:0;text-align:left;"><span style="color:#333333;">尤其是</span><span style="background-color:#f3f4f4;"><span style="color:#333333;">cpu</span></span><span style="color:#333333;">和</span><span style="background-color:#f3f4f4;"><span style="color:#333333;">内存</span></span><span style="color:#333333;">资源。</span></p> <p style="margin-left:0;text-align:left;"><span style="color:#333333;">还有些业务场景比较特殊：</span><span style="background-color:#f3f4f4;"><span style="color:#333333;">写多读少</span></span><span style="color:#333333;">。</span></p> <p style="margin-left:0;text-align:left;"><span style="color:#333333;">如果在这类业务场景中，每个用的写操作，都需要写一次缓存，有点得不偿失。</span></p> <p style="margin-left:0;text-align:left;"><span style="color:#333333;">由此可见，在高并发的场景中，先写数据库，再写缓存，这套方案问题挺多的，也不太建议使用。</span></p> <p style="margin-left:0;text-align:left;"><span style="color:#333333;">如果你已经用了，赶紧看看踩坑了没？</span></p> <div> <p style="margin-left:0;text-align:left;"><strong><span style="color:#333333;">4.</span></strong><strong><span style="color:#333333;">先删缓存，再写数据库</span></strong></p> </div> <p style="margin-left:0;text-align:left;"><span style="color:#333333;">通过上面的内容我们得知，如果直接更新缓存的问题很多。</span></p> <p style="margin-left:0;text-align:left;"><span style="color:#333333;">那么，为何我们不能换一种思路：不去直接</span><span style="background-color:#f3f4f4;"><span style="color:#333333;">更新缓存</span></span><span style="color:#333333;">，而改为</span><span style="background-color:#f3f4f4;"><span style="color:#333333;">删除缓存</span></span><span style="color:#333333;">呢？</span></p> <p style="margin-left:0;text-align:left;"><span style="color:#333333;">删除缓存方案，同样有两种：</span></p> <ol> <li style="text-align:left;"><span style="color:#333333;">先删缓存，再写数据库</span></li> <li style="text-align:left;"><span style="color:#333333;">先写数据库，再删缓存</span></li> </ol> <p style="margin-left:0;text-align:left;"><span style="color:#333333;">我们一起先看看：先删缓存，再写数据库的情况。</span></p> <p style="margin-left:0;text-align:left;"><img loading="lazy" decoding="async" alt="" height="366" src="http://img.555519.xyz/uploads3/20220821/a98c7205f18e8e3b90023e88bf59db56.jpg"></p> <p style="margin-left:0;text-align:left;"><span style="color:#333333;">说白了，在用户的写操作中，先执行删除缓存操作，再去写数据库。这套方案，可以是可以，但也会有一样问题。</span></p> <p style="margin-left:0;text-align:left;"><strong><span style="color:#333333;">4.1</span></strong><strong><span style="color:#333333;">高并发下的问题</span></strong></p> <p style="margin-left:0;text-align:left;"><span style="color:#333333;">假设在高并发的场景中，同一个用户的同一条数据，有一个读数据请求</span><span style="color:#333333;">c</span><span style="color:#333333;">，还有另一个写数据请求</span><span style="color:#333333;">d（一个更新操作），同时请求到业务系统。如下图所示：</span><img loading="lazy" decoding="async" alt="" height="600" src="http://img.555519.xyz/uploads3/20220821/26be493be0b2c015f334acd5dc74f9d2.jpg"></p> <ol> <li style="text-align:left;"><span style="color:#333333;">请求d先过来，把缓存删除了。但由于网络原因，卡顿了一下，还没来得及写数据库。</span></li> <li style="text-align:left;"><span style="color:#333333;">这时请求c过来了，先查缓存发现没数据，再查数据库，有数据，但是旧值。</span></li> <li style="text-align:left;"><span style="color:#333333;">请求c将数据库中的旧值，更新到缓存中。</span></li> <li style="text-align:left;"><span style="color:#333333;">此时，请求d卡顿结束，把新值写入数据库。</span></li> </ol> <p style="margin-left:0;text-align:left;"><span style="color:#333333;">在这个过程当中，请求</span><span style="color:#333333;">d</span><span style="color:#333333;">的新值并没有被请求</span><span style="color:#333333;">c</span><span style="color:#333333;">写入缓存，同样会导致缓存和数据库的数据不一致的情况。更正：图中步骤</span><span style="color:#333333;">7</span><span style="color:#333333;">写入旧值，步骤</span><span style="color:#333333;">9</span><span style="color:#333333;">要删掉。</span></p> <p style="margin-left:0;text-align:left;"><span style="color:#333333;">那么，这种场景的数据不一致问题，能否解决呢？</span></p> <p style="margin-left:0;text-align:left;"><strong><span style="color:#333333;">4.2</span></strong><strong><span style="color:#333333;">缓存双删</span></strong></p> <p style="margin-left:0;text-align:left;"><span style="color:#333333;">在上面的业务场景中，一个读数据请求，一个写数据请求。当写数据请求把缓存删了之后，读数据请求，可能把当时从数据库查询出来的旧值，写入缓存当中。</span></p> <p style="margin-left:0;text-align:left;"><span style="color:#333333;">有人说还不好办，请求</span><span style="color:#333333;">d</span><span style="color:#333333;">在写完数据库之后，把缓存重新删一次不就行了？</span></p> <p style="margin-left:0;text-align:left;"><img loading="lazy" decoding="async" alt="" height="480" src="http://img.555519.xyz/uploads3/20220821/03ba20879d006a017085d65178762977.jpg"></p> <p style="margin-left:0;text-align:left;"><span style="color:#333333;">这就是我们所说的</span><span style="background-color:#f3f4f4;"><span style="color:#333333;">缓存双删</span></span><span style="color:#333333;">，即在写数据库之前删除一次，写完数据库后，再删除一次。</span></p> <p style="margin-left:0;text-align:left;"><span style="color:#333333;">该方案有个非常关键的地方是：第二次删除缓存，并非立马就删，而是要在一定的</span><span style="background-color:#f3f4f4;"><span style="color:#333333;">时间间隔</span></span><span style="color:#333333;">之后。</span></p> <p style="margin-left:0;text-align:left;"><span style="color:#333333;">我们再重新回顾一下，高并发下一个读数据请求，一个写数据请求导致数据不一致的产生过程：</span></p> <ol> <li style="text-align:left;"><span style="color:#333333;">请求d先过来，把缓存删除了。但由于网络原因，卡顿了一下，还没来得及写数据库。</span></li> <li style="text-align:left;"><span style="color:#333333;">这时请求c过来了，先查缓存发现没数据，再查数据库，有数据，但是旧值。</span></li> <li style="text-align:left;"><span style="color:#333333;">请求c将数据库中的旧值，更新到缓存中。</span></li> <li style="text-align:left;"><span style="color:#333333;">此时，请求d卡顿结束，把新值写入数据库。</span></li> <li style="text-align:left;"><span style="color:#333333;">一段时间之后，比如：500ms，请求d将缓存删除。</span></li> </ol> <p style="margin-left:0;text-align:left;"><span style="color:#333333;">这样来看确实可以解决缓存不一致问题。</span></p> <p style="margin-left:0;text-align:left;"><span style="color:#333333;">那么，为什么一定要间隔一段时间之后，才能删除缓存呢？</span></p> <p style="margin-left:0;text-align:left;"><span style="color:#333333;">请求</span><span style="color:#333333;">d</span><span style="color:#333333;">卡顿结束，把新值写入数据库后，请求</span><span style="color:#333333;">c</span><span style="color:#333333;">将数据库中的旧值，更新到缓存中。</span></p> <p style="margin-left:0;text-align:left;"><span style="color:#333333;">此时，如果请求</span><span style="color:#333333;">d</span><span style="color:#333333;">删除太快，在请求</span><span style="color:#333333;">c</span><span style="color:#333333;">将数据库中的旧值更新到缓存之前，就已经把缓存删除了，这次删除就没任何意义。必须要在请求</span><span style="color:#333333;">c</span><span style="color:#333333;">更新缓存之后，再删除缓存，才能把旧值及时删除了。</span></p> <p style="margin-left:0;text-align:left;"><span style="color:#333333;">所以需要在请求</span><span style="color:#333333;">d</span><span style="color:#333333;">中加一个时间间隔，确保请求</span><span style="color:#333333;">c</span><span style="color:#333333;">，或者类似于请求</span><span style="color:#333333;">c</span><span style="color:#333333;">的其他请求，如果在缓存中设置了旧值，最终都能够被请求</span><span style="color:#333333;">d</span><span style="color:#333333;">删除掉。</span></p> <p style="margin-left:0;text-align:left;"><span style="color:#333333;">接下来，还有一个问题：如果第二次删除缓存时，删除失败了该怎么办？</span></p> <p style="margin-left:0;text-align:left;"><span style="color:#333333;">这里先留点悬念，后面会详细说。</span></p> <div> <p style="margin-left:0;text-align:left;"><strong><span style="color:#333333;">5.</span></strong><strong><span style="color:#333333;">先写数据库，再删缓存</span></strong></p> </div> <p style="margin-left:0;text-align:left;"><span style="color:#333333;">从前面得知，先删缓存，再写数据库，在并发的情况下，也可能会出现缓存和数据库的数据不一致的情况。</span></p> <p style="margin-left:0;text-align:left;"><span style="color:#333333;">那么，我们只能寄希望于最后的方案了。</span></p> <p style="margin-left:0;text-align:left;"><span style="color:#333333;">接下来，我们重点看看先写数据库，再删缓存的方案。</span></p> <p style="margin-left:0;text-align:left;"><img loading="lazy" decoding="async" alt="" height="372" src="http://img.555519.xyz/uploads3/20220821/0cc858241b3170edfa5387f19516f47c.jpg"></p> <p style="margin-left:0;text-align:left;"><span style="color:#333333;">在高并发的场景中，有一个读数据请求，有一个写数据请求，更新过程如下：</span></p> <ol> <li style="text-align:left;"><span style="color:#333333;">请求e先写数据库，由于网络原因卡顿了一下，没有来得及删除缓存。</span></li> <li style="text-align:left;"><span style="color:#333333;">请求f查询缓存，发现缓存中有数据，直接返回该数据。</span></li> <li style="text-align:left;"><span style="color:#333333;">请求e删除缓存。</span></li> </ol> <p style="margin-left:0;text-align:left;"><span style="color:#333333;">在这个过程中，只有请求</span><span style="color:#333333;">f</span><span style="color:#333333;">读了一次旧数据，后来旧数据被请求</span><span style="color:#333333;">e</span><span style="color:#333333;">及时删除了，看起来问题不大。</span></p> <p style="margin-left:0;text-align:left;"><span style="color:#333333;">但如果是读数据请求先过来呢？</span></p> <ol> <li style="text-align:left;"><span style="color:#333333;">请求f查询缓存，发现缓存中有数据，直接返回该数据。</span></li> <li style="text-align:left;"><span style="color:#333333;">请求e先写数据库。</span></li> <li style="text-align:left;"><span style="color:#333333;">请求e删除缓存。</span></li> </ol> <p style="margin-left:0;text-align:left;"><span style="color:#333333;">这种情况看起来也没问题呀？</span></p> <p style="margin-left:0;text-align:left;"><span style="color:#333333;">答：对的。</span></p> <p style="margin-left:0;text-align:left;"><span style="color:#333333;">但就怕出现下面这种情况，即缓存自己失效了。如下图所示：</span><img loading="lazy" decoding="async" alt="" height="568" src="http://img.555519.xyz/uploads3/20220821/0a7eb2ef9caeca69ecf10fc906f4e26b.jpg"></p> <ol> <li style="text-align:left;"><span style="color:#333333;">缓存过期时间到了，自动失效。</span></li> <li style="text-align:left;"><span style="color:#333333;">请求f查询缓存，发缓存中没有数据，查询数据库的旧值，但由于网络原因卡顿了，没有来得及更新缓存。</span></li> <li style="text-align:left;"><span style="color:#333333;">请求e先写数据库，接着删除了缓存。</span></li> <li style="text-align:left;"><span style="color:#333333;">请求f更新旧值到缓存中。</span></li> </ol> <p style="margin-left:0;text-align:left;"><span style="color:#333333;">这时，缓存和数据库的数据同样出现不一致的情况了。</span></p> <p style="margin-left:0;text-align:left;"><span style="color:#333333;">但这种情况还是比较少的，需要同时满足以下条件才可以：</span></p> <ol> <li style="text-align:left;"><span style="color:#333333;">缓存刚好自动失效。</span></li> <li style="text-align:left;"><span style="color:#333333;">请求f从数据库查出旧值，更新缓存的耗时，比请求e写数据库，并且删除缓存的还长。</span></li> </ol> <p style="margin-left:0;text-align:left;"><span style="color:#333333;">我们都知道查询数据库的速度，一般比写数据库要快，更何况写完数据库，还要删除缓存。所以绝大多数情况下，写数据请求比读数据情况耗时更长。</span></p> <p style="margin-left:0;text-align:left;"><span style="color:#333333;">由此可见，系统同时满足上述两个条件的概率非常小。</span></p> <p style="margin-left:0;text-align:left;"><span style="color:#777777;">推荐大家使用先写数据库，再删缓存的方案，虽说不能</span><span style="color:#777777;">100%</span><span style="color:#777777;">避免数据不一致问题，但出现该问题的概率，相对于其他方案来说是最小的。</span></p> <p style="margin-left:0;text-align:left;"><span style="color:#333333;">但在该方案中，如果删除缓存失败了该怎么办呢？</span></p> <div> <p style="margin-left:0;text-align:left;"><strong><span style="color:#333333;">6.</span></strong><strong><span style="color:#333333;">删缓存失败怎么办？</span></strong></p> </div> <p style="margin-left:0;text-align:left;"><span style="color:#333333;">其实先写数据库，再删缓存的方案，跟缓存双删的方案一样，有一个共同的风险点，即：如果缓存删除失败了，也会导致缓存和数据库的数据不一致。</span></p> <p style="margin-left:0;text-align:left;"><span style="color:#333333;">那么，删除缓存失败怎么办呢？</span></p> <p style="margin-left:0;text-align:left;"><span style="color:#333333;">答：需要加</span><span style="background-color:#f3f4f4;"><span style="color:#333333;">重试机制</span></span><span style="color:#333333;">。</span></p> <p style="margin-left:0;text-align:left;"><span style="color:#333333;">在接口中如果更新了数据库成功了，但更新缓存失败了，可以立刻重试</span><span style="color:#333333;">3</span><span style="color:#333333;">次。如果其中有任何一次成功，则直接返回成功。如果</span><span style="color:#333333;">3</span><span style="color:#333333;">次都失败了，则写入数据库，准备后续再处理。</span></p> <p style="margin-left:0;text-align:left;"><span style="color:#333333;">当然，如果你在接口中直接</span><span style="background-color:#f3f4f4;"><span style="color:#333333;">同步重试</span></span><span style="color:#333333;">，该接口并发量比较高的时候，可能有点影响接口性能。</span></p> <p style="margin-left:0;text-align:left;"><span style="color:#333333;">这时，就需要改成</span><span style="background-color:#f3f4f4;"><span style="color:#333333;">异步重试</span></span><span style="color:#333333;">了。</span></p> <p style="margin-left:0;text-align:left;"><span style="color:#333333;">异步重试方式有很多种，比如：</span></p> <ol> <li style="text-align:left;"><span style="color:#333333;">每次都单独起一个线程，该线程专门做重试的工作。但如果在高并发的场景下，可能会创建太多的线程，导致系统OOM问题，不太建议使用。</span></li> <li style="text-align:left;"><span style="color:#333333;">将重试的任务交给线程池处理，但如果服务器重启，部分数据可能会丢失。</span></li> <li style="text-align:left;"><span style="color:#333333;">将重试数据写表，然后使用elastic-job等定时任务进行重试。</span></li> <li style="text-align:left;"><span style="color:#333333;">将重试的请求写入mq等消息中间件中，在mq的consumer中处理。</span></li> <li style="text-align:left;"><span style="color:#333333;">订阅mysql的binlog，在订阅者中，如果发现了更新数据请求，则删除相应的缓存。</span></li> </ol> <div> <p style="margin-left:0;text-align:left;"><strong><span style="color:#333333;">7.</span></strong><strong><span style="color:#333333;">定时任务</span></strong></p> </div> <p style="margin-left:0;text-align:left;"><span style="color:#333333;">使用</span><span style="background-color:#f3f4f4;"><span style="color:#333333;">定时任务重试</span></span><span style="color:#333333;">的具体方案如下：</span></p> <ol> <li style="text-align:left;"><span style="color:#333333;">当用户操作写完数据库，但删除缓存失败了，需要将用户数据写入重试表中。如下图所示：</span><img loading="lazy" decoding="async" alt="" height="846" src="http://img.555519.xyz/uploads3/20220821/ff3e6bcdc9d8db4fe37e8460ba34a52a.jpg"></li> <li style="text-align:left;"><span style="color:#333333;">在定时任务中，异步读取重试表中的用户数据。重试表需要记录一个重试次数字段，初始值为0。然后重试5次，不断删除缓存，每重试一次该字段值+1。如果其中有任意一次成功了，则返回成功。如果重试了5次，还是失败，则我们需要在重试表中记录一个失败的状态，等待后续进一步处理。</span><img loading="lazy" decoding="async" alt="" height="976" src="http://img.555519.xyz/uploads3/20220821/1971301660f79e4a1785b5c07be84001.jpg"></li> <li style="text-align:left;"><span style="color:#333333;">在高并发场景中，定时任务推荐使用<span style="background-color:#f3f4f4;">elastic-job</span>。相对于xxl-job等定时任务，它可以分片处理，提升处理速度。同时每片的间隔可以设置成：1,2,3,5,7秒等。</span></li> </ol> <p style="margin-left:0;text-align:left;"><span style="color:#333333;">使用定时任务重试的话，有个缺点就是实时性没那么高，对于实时性要求特别高的业务场景，该方案不太适用。但是对于一般场景，还是可以用一用的。</span></p> <p style="margin-left:0;text-align:left;"><span style="color:#333333;">但它有一个很大的优点，即数据是落库的，不会丢数据。</span></p> <div> <p style="margin-left:0;text-align:left;"><strong><span style="color:#333333;">8. mq</span></strong></p> </div> <p style="margin-left:0;text-align:left;"><span style="color:#333333;">在高并发的业务场景中，</span><span style="color:#333333;">mq</span><span style="color:#333333;">（消息队列）是必不可少的技术之一。它不仅可以异步解耦，还能削峰填谷。对保证系统的稳定性是非常有意义的。</span></p> <p style="margin-left:0;text-align:left;"><span style="color:#333333;">mq</span><span style="color:#333333;">的生产者，生产了消息之后，通过指定的</span><span style="color:#333333;">topic</span><span style="color:#333333;">发送到</span><span style="color:#333333;">mq</span><span style="color:#333333;">服务器。然后</span><span style="color:#333333;">mq</span><span style="color:#333333;">的消费者，订阅该</span><span style="color:#333333;">topic</span><span style="color:#333333;">的消息，读取消息数据之后，做业务逻辑处理。</span></p> <p style="margin-left:0;text-align:left;"><span style="color:#333333;">使用</span><span style="background-color:#f3f4f4;"><span style="color:#333333;">mq</span></span><span style="background-color:#f3f4f4;"><span style="color:#333333;">重试</span></span><span style="color:#333333;">的具体方案如下：</span><img loading="lazy" decoding="async" alt="" height="685" src="http://img.555519.xyz/uploads3/20220821/b6d34f4be2ce6acc6774037b2fc13094.jpg"></p> <ol> <li style="text-align:left;"><span style="color:#333333;">当用户操作写完数据库，但删除缓存失败了，产生一条mq消息，发送给mq服务器。</span></li> <li style="text-align:left;"><span style="color:#333333;">mq消费者读取mq消息，重试5次删除缓存。如果其中有任意一次成功了，则返回成功。如果重试了5次，还是失败，则写入<span style="background-color:#f3f4f4;">死信队列</span>中。</span></li> <li style="text-align:left;"><span style="color:#333333;">推荐mq使用<span style="background-color:#f3f4f4;">rocketmq</span>，重试机制和死信队列默认是支持的。使用起来非常方便，而且还支持顺序消息，延迟消息和事务消息等多种业务场景。</span></li> </ol> <p style="margin-left:0;text-align:left;"><span style="color:#333333;">当然在该方案中，删除缓存可以完全走异步。即用户的写操作，在写完数据库之后，不用立刻删除一次缓存。而直接发送</span><span style="color:#333333;">mq</span><span style="color:#333333;">消息，到</span><span style="color:#333333;">mq</span><span style="color:#333333;">服务器，然后有</span><span style="color:#333333;">mq</span><span style="color:#333333;">消费者全权负责删除缓存的任务。</span></p> <p style="margin-left:0;text-align:left;"><span style="color:#333333;">因为</span><span style="color:#333333;">mq</span><span style="color:#333333;">的实时性还是比较高的，因此改良后的方案也是一种不错的选择。</span></p> <div> <p style="margin-left:0;text-align:left;"><strong><span style="color:#333333;">9. binlog</span></strong></p> </div> <p style="margin-left:0;text-align:left;"><span style="color:#333333;">前面我们聊过的，无论是定时任务，还是</span><span style="color:#333333;">mq</span><span style="color:#333333;">（消息队列），做重试机制，对业务都有一定的侵入性。</span></p> <p style="margin-left:0;text-align:left;"><span style="color:#333333;">在使用定时任务的方案中，需要在业务代码中增加额外逻辑，如果删除缓存失败，需要将数据写入重试表。</span></p> <p style="margin-left:0;text-align:left;"><span style="color:#333333;">而使用</span><span style="color:#333333;">mq</span><span style="color:#333333;">的方案中，如果删除缓存失败了，需要在业务代码中发送</span><span style="color:#333333;">mq</span><span style="color:#333333;">消息到</span><span style="color:#333333;">mq</span><span style="color:#333333;">服务器。</span></p> <p style="margin-left:0;text-align:left;"><span style="color:#333333;">其实，还有一种更优雅的实现，即</span><span style="background-color:#f3f4f4;"><span style="color:#333333;">监听</span></span><span style="background-color:#f3f4f4;"><span style="color:#333333;">binlog</span></span><span style="color:#333333;">，比如使用：</span><span style="background-color:#f3f4f4;"><span style="color:#333333;">canal</span></span><span style="color:#333333;">等中间件。</span></p> <p style="margin-left:0;text-align:left;"><span style="color:#333333;">具体方案如下：</span><img loading="lazy" decoding="async" alt="" height="427" src="http://img.555519.xyz/uploads3/20220821/fce6eba89d6007ed8f3eaf102d2795fa.jpg"></p> <ol> <li style="text-align:left;"><span style="color:#333333;">在业务接口中写数据库之后，就不管了，直接返回成功。</span></li> <li style="text-align:left;"><span style="color:#333333;">mysql服务器会自动把变更的数据写入binlog中。</span></li> <li style="text-align:left;"><span style="color:#333333;">binlog订阅者获取变更的数据，然后删除缓存。</span></li> </ol> <p style="margin-left:0;text-align:left;"><span style="color:#333333;">这套方案中业务接口确实简化了一些流程，只用关心数据库操作即可，而在</span><span style="color:#333333;">binlog</span><span style="color:#333333;">订阅者中做缓存删除工作。</span></p> <p style="margin-left:0;text-align:left;"><span style="color:#333333;">但如果只是按照图中的方案进行删除缓存，只删除了一次，也可能会失败。</span></p> <p style="margin-left:0;text-align:left;"><span style="color:#333333;">如何解决这个问题呢？</span></p> <p style="margin-left:0;text-align:left;"><span style="color:#333333;">答：这就需要加上前面聊过的</span><span style="background-color:#f3f4f4;"><span style="color:#333333;">重试机制</span></span><span style="color:#333333;">了。如果删除缓存失败，写入重试表，使用定时任务重试。或者写入</span><span style="color:#333333;">mq</span><span style="color:#333333;">，让</span><span style="color:#333333;">mq</span><span style="color:#333333;">自动重试。</span></p> <p style="margin-left:0;text-align:left;"><span style="color:#333333;">在这里推荐使用</span><span style="background-color:#f3f4f4;"><span style="color:#333333;">mq</span></span><span style="background-color:#f3f4f4;"><span style="color:#333333;">自动重试机制</span></span><span style="color:#333333;">。</span><img loading="lazy" decoding="async" alt="" height="731" src="http://img.555519.xyz/uploads3/20220821/abf407d2d90f60275974a44a1859d372.jpg"><span style="color:#333333;">在binlog</span><span style="color:#333333;">订阅者中如果删除缓存失败，则发送一条</span><span style="color:#333333;">mq</span><span style="color:#333333;">消息到</span><span style="color:#333333;">mq</span><span style="color:#333333;">服务器，在</span><span style="color:#333333;">mq</span><span style="color:#333333;">消费者中自动重试</span><span style="color:#333333;">5</span><span style="color:#333333;">次。如果有任意一次成功，则直接返回成功。如果重试</span><span style="color:#333333;">5</span><span style="color:#333333;">次后还是失败，则该消息自动被放入死信队列，后面可能需要人工介入。</span></p> <p style="margin-left:0;text-align:justify;"> </div> 			                </div>
                <div class="col-md-12 mt-5">
                                        <p>上一个：<a href="/html/category/article-212.htm">从查询重写角度理解elasticsearch的高亮原理</a></p>
                                        <p>下一个：<a href="/html/category/article-214.htm">JavaScript找到两个数组之间的差异方法详解</a></p>
                                    </div>

                            </div>
            <div class="col-md-4 w3l-services">
                <h3 class="title-big mb-sm-3 mb-3">热门文章</h3>
<div class="row w3l-achievements">
    <div class="col-lg-12 item">
        <div class="card">
            <div class="box-wrap">
                <h4><a href="/html/category/article-260.htm">dataframe数据自动对齐</a></h4>
                <p>import pandas as pd import numpy as np  # Pandas 可以根据索引实现数据自动对齐，索引不重合的部分被置为NaN  df1 = pd.DataFrame(n</p>
            </div>
        </div>
    </div>
</div>
<div class="row w3l-achievements">
    <div class="col-lg-12 item">
        <div class="card">
            <div class="box-wrap">
                <h4><a href="/html/category/article-231.htm">通俗易懂：窗口函数案例详解</a></h4>
                <p>什么是窗口函数 相信很多人都比较熟悉 SQL 聚合函数的语法，比如 count(), sum(), max()等， 窗口函数类似聚合函数，不同的是窗口函数不改变原有的行。 窗口函数是数据分析和数据开发</p>
            </div>
        </div>
    </div>
</div>
<div class="row w3l-achievements">
    <div class="col-lg-12 item">
        <div class="card">
            <div class="box-wrap">
                <h4><a href="/html/category/article-250.htm">Redis的数据淘汰策略和数据过期后的删除策略</a></h4>
                <p>Redis的数据淘汰策略  volatile-lru（least recently used）：从已设置过期时间的数据集（server.db[i].expires）中挑选最近最少使用的数据淘汰 vol</p>
            </div>
        </div>
    </div>
</div>
<div class="row w3l-achievements">
    <div class="col-lg-12 item">
        <div class="card">
            <div class="box-wrap">
                <h4><a href="/html/category/article-233.htm">使用Python实现KNN算法解决简单分类问题</a></h4>
                <p>使用Python实现KNN算法解决简单分类问题 KNN分类 KNN算法属于监督学习算法，它可以解决分类问题，也可以解决回归问题。对于一组带标签的数据，当我们使用KNN算法进行分类时，有两种分类方式。K</p>
            </div>
        </div>
    </div>
</div>
<div class="row w3l-achievements">
    <div class="col-lg-12 item">
        <div class="card">
            <div class="box-wrap">
                <h4><a href="/html/category/article-205.htm">Ribbon（一）远程调用RestTemplate</a></h4>
                <p>目录 一、RestTemplate介绍 二、需求说明 1、业务结构及说明 三、模块搭建 1、新建一个maven项目 2、添加ribbon依赖 3、编辑yml 4、主程序 5、编辑RibbonContr</p>
            </div>
        </div>
    </div>
</div>
<div class="row w3l-achievements">
    <div class="col-lg-12 item">
        <div class="card">
            <div class="box-wrap">
                <h4><a href="/html/category/article-238.htm">js数组删除的方法</a></h4>
                <p>js的数组删除，我建议大家使用splice函数，不要使用slice函数，因为slice是返回一个新数组，并不是从原来的数组中删除。 比如： let a=[111,222,333,444]; a.spl</p>
            </div>
        </div>
    </div>
</div>
<div class="row w3l-achievements">
    <div class="col-lg-12 item">
        <div class="card">
            <div class="box-wrap">
                <h4><a href="/html/category/article-223.htm">Spring Security——【认证、授权、注销及权限控制】</a></h4>
                <p>目录 Spring Security简介： 实验环境搭建： 认证和授权 权限控制和注销  Spring Security简介： Spring Security 是针对Spring项目的安全框架，也是S</p>
            </div>
        </div>
    </div>
</div>
<div class="row w3l-achievements">
    <div class="col-lg-12 item">
        <div class="card">
            <div class="box-wrap">
                <h4><a href="/html/category/article-224.htm">go语言panic函数详解</a></h4>
                <p>程序异常被叫做panic，直译为运行时恐慌 当panic被抛出异常后，如果我们没有在程序中添加任何保护措施的话，程序就会打印出panic的详细情况之后，终止运行  panic: runtime err</p>
            </div>
        </div>
    </div>
</div>
<div class="row w3l-achievements">
    <div class="col-lg-12 item">
        <div class="card">
            <div class="box-wrap">
                <h4><a href="/html/category/article-242.htm">PyQt5 按钮Button 添加事件(信号/槽)</a></h4>
                <p>本文基于PyQt5 按钮Buttons样式设计，针对按钮添加响应的点击事件触发。 效果截图:  PyQt 模型设计：  &nbsp;PyQt 设计器截图：  *.UI 源码 &lt;?xml vers</p>
            </div>
        </div>
    </div>
</div>
<div class="row w3l-achievements">
    <div class="col-lg-12 item">
        <div class="card">
            <div class="box-wrap">
                <h4><a href="/html/category/article-204.htm">Kafka启动报错处理：/opt/module/kafka/bin/kafka-run-class.sh: 第 258 行:exec: java: 未找到</a></h4>
                <p>今天在学习Kafka的时候，写了个脚本，用于集群中kafka的群起。发现启动不了。???? 去掉-daemon参数后，继续启动，看到了它报的错误(日志中也有显示)。找不到java？？？ 看了相关资料后</p>
            </div>
        </div>
    </div>
</div>

<h3 class="title-big mb-sm-3 mb-3">归纳</h3>
<div class="row w3l-achievements">
    <div class="col-lg-12 item">
        <div class="card">
            <div class="box-wrap">
                                <h4><span class="badge" style="float: right;">20</span> <a href="/date/2024-06/" title="2024-06 归档">2024-06</a></h4>
                                <h4><span class="badge" style="float: right;">62</span> <a href="/date/2024-05/" title="2024-05 归档">2024-05</a></h4>
                                <h4><span class="badge" style="float: right;">60</span> <a href="/date/2024-04/" title="2024-04 归档">2024-04</a></h4>
                                <h4><span class="badge" style="float: right;">62</span> <a href="/date/2024-03/" title="2024-03 归档">2024-03</a></h4>
                                <h4><span class="badge" style="float: right;">58</span> <a href="/date/2024-02/" title="2024-02 归档">2024-02</a></h4>
                            </div>
        </div>
    </div>
</div>
            </div>
        </div>
    </div>
    
        <!-- Footer -->
    <section class="w3l-footer py-sm-5 py-4">
        <div class="container">
            <div class="footer-content">
                <div class="row">
                    <div class="col-lg-8 footer-left">
                        <p class="m-0">EgyptAddress 版权所有</p>
                    </div>
                    <div class="col-lg-4 footer-right text-lg-right text-center mt-lg-0 mt-3">
                        <ul class="social m-0 p-0">
                            <li><a href="#facebook"><span class="fa fa-facebook-official"></span></a></li>
                            <li><a href="#linkedin"><span class="fa fa-linkedin-square"></span></a></li>
                            <li><a href="#instagram"><span class="fa fa-instagram"></span></a></li>
                            <li><a href="#twitter"><span class="fa fa-twitter"></span></a></li>
                        </ul>
                    </div>
                </div>
            </div>
        </div>
        <!-- move top -->
        <button onclick="topFunction()" id="movetop" title="Go to top">
            <span class="fa fa-angle-up"></span>
        </button>
        <script>
        // When the user scrolls down 20px from the top of the document, show the button
        window.onscroll = function() {
            scrollFunction()
        };

        function scrollFunction() {
            if (document.body.scrollTop > 20 || document.documentElement.scrollTop > 20) {
                document.getElementById("movetop").style.display = "block";
            } else {
                document.getElementById("movetop").style.display = "none";
            }
        }

        // When the user clicks on the button, scroll to the top of the document
        function topFunction() {
            document.body.scrollTop = 0;
            document.documentElement.scrollTop = 0;
        }
        </script>
        <!-- /move top -->
    </section>
    <!-- //Footer -->

    <!-- all js scripts and files here -->
    <script src="/assets/addons/xcblog/js/frontend/egyptaddress/theme-change.js"></script><!-- theme switch js (light and dark)-->
    <script src="/assets/addons/xcblog/js/frontend/egyptaddress/jquery-3.3.1.min.js"></script><!-- default jQuery -->
    <!-- /typig-text-->
    <script>
    const typedTextSpan = document.querySelector(".typed-text");
    const cursorSpan = document.querySelector(".cursor");

    const textArray = ["UI/UX Designer", "Freelancer", "Web developer"];
    const typingDelay = 200;
    const erasingDelay = 10;
    const newTextDelay = 100; // Delay between current and next text
    let textArrayIndex = 0;
    let charIndex = 0;

    function type() {
        if (charIndex < textArray[textArrayIndex].length) {
            if (!cursorSpan.classList.contains("typing")) cursorSpan.classList.add("typing");
            typedTextSpan.textContent += textArray[textArrayIndex].charAt(charIndex);
            charIndex++;
            setTimeout(type, typingDelay);
        } else {
            cursorSpan.classList.remove("typing");
            setTimeout(erase, newTextDelay);
        }
    }

    function erase() {
        if (charIndex > 0) {
            // add class 'typing' if there's none
            if (!cursorSpan.classList.contains("typing")) {
                cursorSpan.classList.add("typing");
            }
            typedTextSpan.textContent = textArray[textArrayIndex].substring(0, 0);
            charIndex--;
            setTimeout(erase, erasingDelay);
        } else {
            cursorSpan.classList.remove("typing");
            textArrayIndex++;
            if (textArrayIndex >= textArray.length) textArrayIndex = 0;
            setTimeout(type, typingDelay);
        }
    }

    document.addEventListener("DOMContentLoaded", function() { // On DOM Load initiate the effect
        if (textArray.length) setTimeout(type, newTextDelay + 250);
    });
    </script>
    <!-- //typig-text-->
    <!-- services owlcarousel -->
    <script src="/assets/addons/xcblog/js/frontend/egyptaddress/owl.carousel.js"></script>
    <!-- script for services -->
    <script>
    $(document).ready(function() {
        $('.owl-two').owlCarousel({
            loop: true,
            margin: 30,
            nav: false,
            responsiveClass: true,
            autoplay: false,
            autoplayTimeout: 5000,
            autoplaySpeed: 1000,
            autoplayHoverPause: false,
            responsive: {
                0: {
                    items: 1,
                    nav: false
                },
                480: {
                    items: 1,
                    nav: false
                },
                700: {
                    items: 1,
                    nav: false
                },
                1090: {
                    items: 3,
                    nav: false
                }
            }
        })
    })
    </script>
    <!-- //script for services -->
    <!-- script for tesimonials carousel slider -->
    <script>
    $(document).ready(function() {
        $("#owl-demo1").owlCarousel({
            loop: true,
            margin: 20,
            nav: false,
            responsiveClass: true,
            responsive: {
                0: {
                    items: 1,
                    nav: false
                },
                736: {
                    items: 1,
                    nav: false
                },
                1000: {
                    items: 2,
                    nav: false,
                    loop: false
                }
            }
        })
    })
    </script>
    <!-- //script for tesimonials carousel slider -->
    <!-- video popup -->
    <script src="/assets/addons/xcblog/js/frontend/egyptaddress/jquery.magnific-popup.min.js"></script>
    <script>
    $(document).ready(function() {
        $('.popup-with-zoom-anim').magnificPopup({
            type: 'inline',

            fixedContentPos: false,
            fixedBgPos: true,

            overflowY: 'auto',

            closeBtnInside: true,
            preloader: false,

            midClick: true,
            removalDelay: 300,
            mainClass: 'my-mfp-zoom-in'
        });

        $('.popup-with-move-anim').magnificPopup({
            type: 'inline',

            fixedContentPos: false,
            fixedBgPos: true,

            overflowY: 'auto',

            closeBtnInside: true,
            preloader: false,

            midClick: true,
            removalDelay: 300,
            mainClass: 'my-mfp-slide-bottom'
        });
    });
    </script>
    <!-- //video popup -->
    <!-- stats number counter-->
    <script src="/assets/addons/xcblog/js/frontend/egyptaddress/jquery.waypoints.min.js"></script>
    <script src="/assets/addons/xcblog/js/frontend/egyptaddress/jquery.countup.js"></script>
    <script>
    $('.counter').countUp();
    </script>
    <!-- //stats number counter -->
    <!-- disable body scroll which navbar is in active -->
    <script>
    $(function() {
        $('.navbar-toggler').click(function() {
            $('body').toggleClass('noscroll');
        })

        $('.post-content-content .js_to').click(function(){
            var url = $(this).data('url');
            var code = $(this).data('code');
            url += code;

            window.open(url);
        })
    });
    </script>
    <!-- disable body scroll which navbar is in active -->
    <!--/MENU-JS-->
    <script>
    $(window).on("scroll", function() {
        var scroll = $(window).scrollTop();

        if (scroll >= 80) {
            $("#site-header").addClass("nav-fixed");
        } else {
            $("#site-header").removeClass("nav-fixed");
        }
    });

    //Main navigation Active Class Add Remove
    $(".navbar-toggler").on("click", function() {
        $("header").toggleClass("active");
    });
    $(document).on("ready", function() {
        if ($(window).width() > 991) {
            $("header").removeClass("active");
        }
        $(window).on("resize", function() {
            if ($(window).width() > 991) {
                $("header").removeClass("active");
            }
        });
    });
    </script>
    <!--//MENU-JS-->
    <!-- bootstrap js -->
    <script src="/assets/addons/xcblog/js/frontend/egyptaddress/bootstrap.min.js"></script>
</body>

</html>